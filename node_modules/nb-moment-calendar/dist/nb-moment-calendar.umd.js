(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment'), require('immutable'), require('lodash')) :
  typeof define === 'function' && define.amd ? define(['exports', 'moment', 'immutable', 'lodash'], factory) :
  (factory((global.NBMomentCalendar = global.NBMomentCalendar || {}),global.moment,global.Immutable,global._));
}(this, (function (exports,moment,Immutable,_) { 'use strict';

moment = 'default' in moment ? moment['default'] : moment;
Immutable = 'default' in Immutable ? Immutable['default'] : Immutable;
_ = 'default' in _ ? _['default'] : _;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

/**
 * ES6 version of the origin nb-moment-calendar
 * and support the jsmain:next output
 */

// main

var NbMomentCalendar = function () {
    /**
     * class constructor
     * @param {object} config to extend
     */
    function NbMomentCalendar() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        classCallCheck(this, NbMomentCalendar);

        var options = {
            locale: 'en-gb',
            localeConfig: {
                weekdaysMin: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
                weekdaysShort: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
                week: {
                    dow: 1 // Monday is the first day of the week
                }
            }
        };
        this.logger = config.logger || function () {};
        this.options = _.extend({}, options, config);
        this.moment = moment;
        this.moment.locale(this.options.locale, this.options.localeConfig);
        // the dow affect the weekday index to determine when its weekend!
        this.weekendIndex = this.options.localeConfig.week.dow === 1 ? [5, 6] : [0, 6];

        this.__cacheMap__ = null;
        this.PADDED_MONTH = 2;
    }

    ///////////////////////////////
    //		PUBLIC METHODS		 //
    ///////////////////////////////

    /**
     * The init now run at the constructor level
     * @return {object} moment
     */


    createClass(NbMomentCalendar, [{
        key: 'getMoment',
        value: function getMoment() {
            return this.moment;
        }

        /**
         * retrieve the config values
         * @return {object} options
         */

    }, {
        key: 'getConfig',
        value: function getConfig() {
            return this.options;
        }
        /**
         * main interface for retrieve the month by weeks in the year
         * this is cache
         * @param {int} year 4 digit (or any moment.js accpetable year)
         * @param {int} month digit (or any moment.js acceptable month)
         * @return {object} months
         */

    }, {
        key: 'getMonth',
        value: function getMonth(year, month) {
            return this.__getMergeMonth__(year, month);
        }

        /**
         * return 12 months from the year
         * @param {int} year
         * @param {string} headingFormat pass a heading moment format
         * @return {array} blocks of month with {year, month, heading, data}
         */

    }, {
        key: 'getYear',
        value: function getYear(year, headingFormat) {
            var months = this.__getMonthObjects__(year, 1, 12 + this.PADDED_MONTH);
            return this.__getMonthBlocks__(months, headingFormat);
        }

        /**
         * return X months from the date forward
         * @param {int} year
         * @param {int} month
         * @param {int} how many months to turn
         * @param {string} formating for heaidng
         * @return {array} blocks of month with {year, month, heading, data}
         */

    }, {
        key: 'getMonths',
        value: function getMonths(year, month, total, headingFormat) {
            this.logger('getMonths look at this context', this);
            var months = this.__getMonthObjects__(year, month, total + this.PADDED_MONTH);
            // remember its always 1 before 1 after, so need to add two
            return this.__getMonthBlocks__(months, headingFormat);
        }

        /**
         * this will get you the month data , no padding
         * @param {int} year
         * @param {int} month (not index)
         * @param {int} total how many months to get default 3
         * @return {object} months
         */

    }, {
        key: 'getRawMonths',
        value: function getRawMonths(year, month, total) {
            var _this = this;

            var months = this.__getMonthObjects__(year, month, total);
            return months.map(function (obj) {
                return _this.__generateWeeksInMonth__(obj.obj, obj.year, obj.mIdx);
            });
        }

        ///////////////////////////////////
        //      PRIVATE METHODS          //
        ///////////////////////////////////

        /**
         * add pad key during merge otherwise the cache version will always store the padded key
         * @param {object} padding the months
         * @return {object} transform
         */

    }, {
        key: '__addPad__',
        value: function __addPad__(row) {
            var _row = _.extend({}, row); // need to do this with a copy otherwise it mutated.
            return _.transform(_row, function (result, n, key) {
                n.pad = true;
                result[key] = n;
            });
        }

        /**
         * merge them together and strip out those we don't need
         * @TODO need to fix this - the object still getting overwritten when use the cache version
         * @param {array} months 3 months
         * @return {object} thisMonth
         */

    }, {
        key: '__mergeMonth__',
        value: function __mergeMonth__(months) {
            var thisMonth = months[1];
            // first row
            if (_.size(thisMonth[0]) !== 7) {
                var lastRowInLastMonth = this.__addPad__(_.last(months[0]));
                thisMonth[0] = _.merge({}, lastRowInLastMonth, thisMonth[0]);
            }
            var lastRowOfThisMonth = _.last(thisMonth);
            var mergeFirstRow = false;
            // last row
            if (_.size(lastRowOfThisMonth) !== 7) {
                var firstRowOfNextMonth = this.__addPad__(_.first(months[2]));
                thisMonth[thisMonth.length - 1] = _.merge({}, lastRowOfThisMonth, firstRowOfNextMonth);
                mergeFirstRow = true;
            }
            var ctn = thisMonth.length;
            var pad = 6 - ctn;
            var startIdx = mergeFirstRow ? 1 : 0;
            if (pad > 0) {
                for (var i = 0; i < pad; ++i) {
                    var idx = startIdx + i;
                    thisMonth[ctn] = this.__addPad__(months[2][idx]);
                    ++ctn;
                }
            }
            return thisMonth;
        }

        /**
         * generate X months object
         * @param {int} year what year
         * @param {int} month (not index)
         * @param {int} total how many months
         * @return {array} monthObjs
         */

    }, {
        key: '__getMonthObjects__',
        value: function __getMonthObjects__(year, month, total) {
            total = total || 3; // default 3 months
            year = parseInt(year);
            month = parseInt(month);
            // first we get the current month
            // then we get last month as the starting point
            var monthIdx = month - 1;
            var monthsObj = [];
            var currentDateMoment = this.getMoment()([year, monthIdx]);
            var lastMonthDateMoment = currentDateMoment.clone().subtract(1, 'month');
            var lastMonthDate = lastMonthDateMoment.format('M');
            // get the first 2 months
            monthsObj.push({
                year: lastMonthDateMoment.format('YYYY'),
                mIdx: lastMonthDate - 1,
                month: lastMonthDate,
                obj: lastMonthDateMoment
            });
            monthsObj.push({
                year: year,
                mIdx: monthIdx,
                month: month,
                obj: currentDateMoment
            });
            // loop the next part
            total = total - 2;
            for (var i = 0; i < total; ++i) {
                var add = i + 1;
                var nextMonthDateMoment = currentDateMoment.clone().add(add, 'month');
                var nextMonthDate = nextMonthDateMoment.format('M');
                monthsObj.push({
                    year: nextMonthDateMoment.format('YYYY'),
                    mIdx: nextMonthDate - 1,
                    month: nextMonthDate,
                    obj: nextMonthDateMoment
                });
            }
            this.logger('__getMonthObjects__', monthsObj);
            return monthsObj;
        }

        /**
         * this really is the only one we want to cache
         * @param {object} momentObj an instance of moment
         * @param {int} year in 4 digit (or any moment accept year format)
         * @param {int} monthIdx index of month (start from 0 --> january)
         * @return {array} weeks
         */

    }, {
        key: '__generateWeeksInMonthCore__',
        value: function __generateWeeksInMonthCore__(momentObj, year, monthIdx) {
            /*
            cache is still wrong!!!!
            const cacheKey = [year , monthIdx , 'weeks'].join('-'),
                  cache = this.__getCache__(cacheKey);
            if (cache) {
                return cache;
            } */
            var totalDays = momentObj.daysInMonth(),
                weeks = [];
            var j = 0;
            for (var i = 0; i < totalDays; ++i) {
                var d = i + 1;
                var _date = momentObj.clone();
                _date.set('year', year);
                _date.set('month', monthIdx);
                _date.set('date', d);
                var dayOfWeek = parseInt(_date.format('e'));
                if (_.isUndefined(weeks[j])) {
                    weeks[j] = {};
                }
                // const wend = _date.format('d');
                weeks[j][dayOfWeek] = {
                    'day': _date.format('D'),
                    'dow': dayOfWeek,
                    'wend': (dayOfWeek !== this.weekendIndex[0] && dayOfWeek !== this.weekendIndex[1]) === false, // add at V0.7.0
                    'fday': _date.format('YYYY-MM-DD'),
                    'wday': _date.isoWeekday() // added on 12 Jan 2016
                };
                if (dayOfWeek >= 6) {
                    ++j;
                }
            }
            return weeks;
            // return this.__setCache__(cacheKey , weeks);
        }

        /**
         * this will always merge 3 months together and pad them
         * @param {array} months 3 months object
         * @param {string} cacheKey to id the cache
         * @return {object} month object
         */

    }, {
        key: '__mergeMonthCore__',
        value: function __mergeMonthCore__(months, cacheKey) {
            var _this2 = this;

            // @TODO see if we really want to cache this or not
            return this.__mergeMonth__(months.map(function (obj) {
                return _this2.__generateWeeksInMonth__(obj.obj, obj.year, obj.mIdx);
            }));
        }

        /**
         * the underlying method for `get`, this will always pass 3 months to create one month
         * @param {int} year 4 digit (or any moment.js accpetable year)
         * @param {int} month digit (or any moment.js acceptable month)
         * @return {object} monthYear
         */

    }, {
        key: '__getMergeMonth__',
        value: function __getMergeMonth__(year, month) {
            var cacheKey = [year, month, 'merge'].join('-');
            // const cache = this.__getCache__(cacheKey);
            var months = this.__getMonthObjects__(year, month);
            // when in other class this throw __getMonthObjects__ is undefined?
            return this.__mergeMonthCore__(months, cacheKey);
        }

        /**
         * this become a public interface now , see generateWeeksInMonthCore
         * @param {object} momentObj moment instance
         * @param {int} year year
         * @param {int} monthIdx indexed version of the moment
         * @return {object} month
         */

    }, {
        key: '__generateWeeksInMonth__',
        value: function __generateWeeksInMonth__(momentObj, year, monthIdx) {
            var cacheKey = [year, monthIdx + 1, 'month'].join('-');
            // const cache = this.__getCache__(cacheKey);
            return this.__generateWeeksInMonthCore__(momentObj, year, monthIdx, cacheKey);
        }

        /**
         * core method share by get year and months
         * @param {array} months of month objects
         * @param {string} headingFormat format for heading
         * @return {array} months the blocks of months
         */

    }, {
        key: '__getMonthBlocks__',
        value: function __getMonthBlocks__(months, headingFormat) {
            headingFormat = headingFormat || 'MMM YYYY';
            var ctn = months.length - this.PADDED_MONTH,
                blocks = [];
            for (var i = 0; i < ctn; ++i) {
                var b = [];
                var month = months[i];
                var key = '',
                    yearName = '',
                    monthName = '',
                    monthIdx = '';
                b.push(month);
                for (var j = 1; j < 3; ++j) {
                    var m = months[j + i];
                    if (j === 1) {
                        yearName = m.year;
                        monthName = m.month;
                        monthIdx = m.mIdx;
                        key = [yearName, monthName, 'merge'].join('-');
                    }
                    b.push(m);
                }
                blocks.push({
                    heading: this.getMoment()([yearName, monthIdx]).format(headingFormat),
                    year: yearName,
                    month: monthName,
                    data: this.__mergeMonthCore__(b, key)
                });
            }
            return blocks;
        }

        /**
         * cache setter
         * @param {string} key to
         * @param {mixed} data to store
         * @return {mixed} result
         */

    }, {
        key: '__setCache__',
        value: function __setCache__(key, data) {
            if (!this.__cacheMap__) {
                this.logger('init cache', key, data);
                var initObj = defineProperty({}, key, data);
                return this.__cacheMap__ = Immutable.Map(initObj);
            } else {
                this.logger('update cache', key, data);
                this.__cacheMap__ = this.__cacheMap__.set(key, data);
            }
            return this.__getCache__(key);
        }

        /**
         * @param {string} key to
         * @return {object} cache
         */

    }, {
        key: '__getCache__',
        value: function __getCache__(key) {
            if (!this.__cacheMap__) {
                return false;
            }
            return this.__debug__('return data from cache ' + key, this.__cacheMap__.get(key));
        }

        /**
         * debug code
         * @param {string} msg to show
         * @param {mixed} data pass through
         * @return {mixed} data
         */

    }, {
        key: '__debug__',
        value: function __debug__(msg, data) {
            this.logger(msg, data);
            return data;
        }
    }]);
    return NbMomentCalendar;
}();

exports['default'] = NbMomentCalendar;

Object.defineProperty(exports, '__esModule', { value: true });

})));
