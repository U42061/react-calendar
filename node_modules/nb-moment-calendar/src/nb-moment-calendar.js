'use strict';
/**
 * ES6 version of the origin nb-moment-calendar
 * and support the jsmain:next output
 */
import moment from 'moment';
import Immutable from 'immutable';
import _ from 'lodash';
// main
export default class NbMomentCalendar {
    /**
     * class constructor
     * @param {object} config to extend
     */
    constructor(config = {})
    {
        const options = {
			locale: 'en-gb',
			localeConfig: {
				weekdaysMin: ['Mo' , 'Tu' , 'We' , 'Th' , 'Fr' , 'Sa' , 'Su'],
                weekdaysShort: ['Mon' , 'Tue' , 'Wed' , 'Thu' , 'Fri' , 'Sat' , 'Sun'],
				week : {
        			dow : 1 // Monday is the first day of the week
    			}
			}
		};
        this.logger = config.logger || function() {};
        this.options = _.extend({} , options , config);
        this.moment = moment;
        this.moment.locale(this.options.locale , this.options.localeConfig);
        // the dow affect the weekday index to determine when its weekend!
        this.weekendIndex = (this.options.localeConfig.week.dow === 1) ? [5,6] : [0,6];

        this.__cacheMap__ = null;
        this.PADDED_MONTH = 2;
    }

    ///////////////////////////////
    //		PUBLIC METHODS		 //
    ///////////////////////////////

    /**
     * The init now run at the constructor level
     * @return {object} moment
     */
    getMoment()
    {
        return this.moment;
    }

    /**
     * retrieve the config values
     * @return {object} options
     */
    getConfig()
    {
        return this.options;
    }
    /**
     * main interface for retrieve the month by weeks in the year
     * this is cache
     * @param {int} year 4 digit (or any moment.js accpetable year)
     * @param {int} month digit (or any moment.js acceptable month)
     * @return {object} months
     */
    getMonth(year , month)
    {
        return this.__getMergeMonth__(year , month);
    }

    /**
     * return 12 months from the year
     * @param {int} year
     * @param {string} headingFormat pass a heading moment format
     * @return {array} blocks of month with {year, month, heading, data}
     */
    getYear(year , headingFormat)
    {
        const months = this.__getMonthObjects__(year , 1 , 12 + this.PADDED_MONTH)
        return this.__getMonthBlocks__(
            months ,
            headingFormat
        );
    }

    /**
     * return X months from the date forward
     * @param {int} year
     * @param {int} month
     * @param {int} how many months to turn
     * @param {string} formating for heaidng
     * @return {array} blocks of month with {year, month, heading, data}
     */
    getMonths(year , month , total , headingFormat)
    {
        this.logger('getMonths look at this context' , this);
        const months = this.__getMonthObjects__(year , month , total + this.PADDED_MONTH)
        // remember its always 1 before 1 after, so need to add two
        return this.__getMonthBlocks__(
            months,
            headingFormat
        );
    }

    /**
     * this will get you the month data , no padding
     * @param {int} year
     * @param {int} month (not index)
     * @param {int} total how many months to get default 3
     * @return {object} months
     */
    getRawMonths(year , month , total)
    {
        const months = this.__getMonthObjects__(year , month , total);
        return months.map( (obj) =>
        {
            return this.__generateWeeksInMonth__(obj.obj , obj.year , obj.mIdx);
        });
    }

    ///////////////////////////////////
    //      PRIVATE METHODS          //
    ///////////////////////////////////

    /**
     * add pad key during merge otherwise the cache version will always store the padded key
     * @param {object} padding the months
     * @return {object} transform
     */
    __addPad__(row)
    {
        let _row = _.extend({} , row); // need to do this with a copy otherwise it mutated.
        return _.transform(_row , function(result , n , key)
        {
            n.pad = true;
            result[key] = n;
        });
    }

    /**
     * merge them together and strip out those we don't need
     * @TODO need to fix this - the object still getting overwritten when use the cache version
     * @param {array} months 3 months
     * @return {object} thisMonth
     */
    __mergeMonth__(months)
    {
        let thisMonth = months[1];
        // first row
        if (_.size(thisMonth[0]) !== 7) {
            const lastRowInLastMonth = this.__addPad__(_.last(months[0]));
            thisMonth[0] = _.merge({} , lastRowInLastMonth , thisMonth[0]);
        }
        const lastRowOfThisMonth = _.last(thisMonth);
        let mergeFirstRow = false;
        // last row
        if (_.size(lastRowOfThisMonth) !== 7) {
            const firstRowOfNextMonth = this.__addPad__(_.first(months[2]));
            thisMonth[ thisMonth.length - 1] = _.merge({} , lastRowOfThisMonth , firstRowOfNextMonth);
            mergeFirstRow = true;
        }
        let ctn = thisMonth.length;
        const pad = 6 - ctn;
        const startIdx = (mergeFirstRow) ? 1 : 0;
        if (pad>0) {
            for (let i=0; i<pad; ++i) {
                const idx = startIdx + i;
                thisMonth[ ctn ] = this.__addPad__(months[2][idx]);
                ++ctn;
            }
        }
        return thisMonth;
    }

    /**
     * generate X months object
     * @param {int} year what year
     * @param {int} month (not index)
     * @param {int} total how many months
     * @return {array} monthObjs
     */
    __getMonthObjects__(year , month , total)
    {
        total = total || 3; // default 3 months
        year = parseInt(year);
        month = parseInt(month);
        // first we get the current month
        // then we get last month as the starting point
        const monthIdx  = month - 1;
        const monthsObj = [];
        const currentDateMoment   = this.getMoment()([year , monthIdx]);
        const lastMonthDateMoment = currentDateMoment.clone().subtract(1 , 'month');
        const lastMonthDate = lastMonthDateMoment.format('M');
        // get the first 2 months
        monthsObj.push({
            year: lastMonthDateMoment.format('YYYY') ,
            mIdx: lastMonthDate-1 ,
            month: lastMonthDate ,
            obj: lastMonthDateMoment
        });
        monthsObj.push({
            year: year ,
            mIdx: monthIdx ,
            month: month ,
            obj: currentDateMoment
        });
        // loop the next part
        total = total - 2;
        for (let i=0; i<total; ++i) {
            const add = i + 1;
            const nextMonthDateMoment = currentDateMoment.clone().add(add , 'month');
            const nextMonthDate = nextMonthDateMoment.format('M');
            monthsObj.push({
                year: nextMonthDateMoment.format('YYYY') ,
                mIdx: nextMonthDate-1 ,
                month: nextMonthDate   ,
                obj: nextMonthDateMoment
            });
        }
        this.logger('__getMonthObjects__' , monthsObj);
        return monthsObj;
    }

    /**
     * this really is the only one we want to cache
     * @param {object} momentObj an instance of moment
     * @param {int} year in 4 digit (or any moment accept year format)
     * @param {int} monthIdx index of month (start from 0 --> january)
     * @return {array} weeks
     */
    __generateWeeksInMonthCore__(momentObj , year , monthIdx)
    {
        /*
        cache is still wrong!!!!
        const cacheKey = [year , monthIdx , 'weeks'].join('-'),
              cache = this.__getCache__(cacheKey);
        if (cache) {
            return cache;
        } */
        const totalDays = momentObj.daysInMonth(),
            weeks = [];
        let j = 0;
        for (let i=0; i<totalDays; ++i) {
            const d = i+1;
            const _date = momentObj.clone();
            _date.set('year'  , year);
            _date.set('month' , monthIdx);
            _date.set('date'  , d);
            const dayOfWeek = parseInt(_date.format('e'));
            if (_.isUndefined(weeks[j])) {
                weeks[j] = {};
            }
            // const wend = _date.format('d');
            weeks[j][dayOfWeek] = {
                'day': _date.format('D'),
                'dow': dayOfWeek,
                'wend': (dayOfWeek!==this.weekendIndex[0] && dayOfWeek!==this.weekendIndex[1]) === false, // add at V0.7.0
                'fday': _date.format('YYYY-MM-DD'),
                'wday': _date.isoWeekday() // added on 12 Jan 2016
            };
            if (dayOfWeek>=6) {
                ++j;
            }
        }
        return weeks;
        // return this.__setCache__(cacheKey , weeks);
    }

    /**
     * this will always merge 3 months together and pad them
     * @param {array} months 3 months object
     * @param {string} cacheKey to id the cache
     * @return {object} month object
     */
    __mergeMonthCore__(months , cacheKey)
    {
        // @TODO see if we really want to cache this or not
        return this.__mergeMonth__(
            months.map((obj) =>
            {
                return this.__generateWeeksInMonth__(obj.obj , obj.year , obj.mIdx);
            }
        ));
    }

    /**
     * the underlying method for `get`, this will always pass 3 months to create one month
     * @param {int} year 4 digit (or any moment.js accpetable year)
     * @param {int} month digit (or any moment.js acceptable month)
     * @return {object} monthYear
     */
    __getMergeMonth__(year , month)
    {
        const cacheKey = [year , month , 'merge'].join('-');
        // const cache = this.__getCache__(cacheKey);
        const months = this.__getMonthObjects__(year , month)
        // when in other class this throw __getMonthObjects__ is undefined?
        return this.__mergeMonthCore__(
            months ,
            cacheKey
        );
    }

    /**
     * this become a public interface now , see generateWeeksInMonthCore
     * @param {object} momentObj moment instance
     * @param {int} year year
     * @param {int} monthIdx indexed version of the moment
     * @return {object} month
     */
    __generateWeeksInMonth__(momentObj , year , monthIdx)
    {
        const cacheKey = [year , (monthIdx+1) , 'month'].join('-');
        // const cache = this.__getCache__(cacheKey);
        return this.__generateWeeksInMonthCore__(momentObj , year , monthIdx , cacheKey);
    }

    /**
     * core method share by get year and months
     * @param {array} months of month objects
     * @param {string} headingFormat format for heading
     * @return {array} months the blocks of months
     */
    __getMonthBlocks__(months, headingFormat)
    {
        headingFormat = headingFormat || 'MMM YYYY';
        const ctn = months.length - this.PADDED_MONTH,
            blocks = [];
        for (let i=0; i < ctn; ++i) {
            const b = [];
            const month = months[i];
            let key = '' , yearName = '', monthName = '' , monthIdx = '';
            b.push(month);
            for (let j=1; j<3; ++j) {
                const m = months[j+i];
                if (j===1) {
                    yearName = m.year;
                    monthName = m.month;
                    monthIdx = m.mIdx;
                    key = [yearName , monthName , 'merge'].join('-');
                }
                b.push(m);
            }
            blocks.push({
                heading: this.getMoment()([yearName , monthIdx]).format(headingFormat),
                year: yearName,
                month: monthName,
                data: this.__mergeMonthCore__(b , key)
            });
        }
        return blocks;
    }

    /**
     * cache setter
     * @param {string} key to
     * @param {mixed} data to store
     * @return {mixed} result
     */
    __setCache__(key , data)
    {
        if (!this.__cacheMap__) {
            this.logger('init cache' , key , data);
            let initObj = {[key]: data};
            return (
                this.__cacheMap__ = Immutable.Map(initObj)
            );
        }
        else {
            this.logger('update cache' , key , data);
            this.__cacheMap__ = this.__cacheMap__.set(key , data);
        }
        return this.__getCache__(key);
    }

    /**
     * @param {string} key to
     * @return {object} cache
     */
    __getCache__(key)
    {
        if (!this.__cacheMap__) {
            return false;
        }
        return this.__debug__(
            'return data from cache ' + key,
            this.__cacheMap__.get(key)
        );
    }

    /**
     * debug code
     * @param {string} msg to show
     * @param {mixed} data pass through
     * @return {mixed} data
     */
    __debug__(msg , data)
    {
        this.logger(msg , data);
        return data;
    }
}


// -- EOF --
